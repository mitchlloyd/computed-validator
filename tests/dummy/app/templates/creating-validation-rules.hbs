<h2>Creating Validation Rules</h2>

<p>
  A major goal of Computed Validator is to make custom rules
  easy to create and simple to compose.
</p>

<h3>Using <code>validationRule</code> and <code>validate</code></h3>

<p>
  To create your own validation rule, you'll want to import
  <code>validationRule</code> and <code>validate</code>. As an example,
  here is the included <code>confirmed</code> validation rule.
</p>

{{code-snippet name="confirmed-validation-rule.js"}}

<p>
  <code>validationRule</code> takes a callback whose first
  argument is <i>an array containing the arguments passed when the rule was declared</i> and whose
  second argument is <i>an object containing mata data about the validation rule</i>. Most commonly
  the <code>onProperty</code> option is used to derive a dependent key.
</p>

<p>
  For instance, in the following example the first argument would be an array
  containing the string "password" (<code>['password']</code>) and the second
  argument would be an object with property <code>onProperty</code> of
  "passwordConfirmation".
</p>

{{code-snippet name="confirmed-example-validator.js"}}

<p>
  Ultimately a <code>validationRule</code> call must return an object
  containing an array of <code>dependentKeys</code> and a <code>validate</code>
  function.
</p>

{{code-snippet name="validation-rule-response.js"}}

<h3>Returning a <code>Validation Error</code></h3>

<p>
  Returning a <code>ValidationError</code> instead of a string gives
  Computed Validator a change to translate your error message before
  showing it in your template.
</p>

<p>
  <code>ValidationError</code> is a JavaScript class. Initialize it with
  a translation key and an object containing properties for the translation.
</p>

{{code-snippet name="validation-error-usage.js"}}
